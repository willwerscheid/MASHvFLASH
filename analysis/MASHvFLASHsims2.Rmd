---
title: "MASH v FLASH detailed simulation study"
output: 
  workflowr::wflow_html:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

all.rrmses <- sqrt(readRDS("./output/sims2mse.rds"))
pr.pn <- readRDS("./output/sims2prpn.rds")
pr.ash <- readRDS("./output/sims2prash.rds")
pr.m <- readRDS("./output/sims2prm.rds")

# Nulls
nullidx <- c(7, 9, 11, 13, 15, 23)
null.names <- c("UnSm(7)", "UnLg(8)", "Sh3(9)", "Sh10(10)", "Sh5(11)", "Null")

# Effects that are independent or identical across conditions
indididx <- 1:6
indid.names <- c("IndSm(1)", "IndLg(2)", "IndDif(3)", "IdSm(4)", "IdLg(5)", "Rnk1(6)")

# Effects that are unique to one or several conditions
unshidx <- c(8, 10, 12, 14, 16)
unsh.names <- c("UnSm(7)", "UnLg(8)", "Sh3(9)", "Sh10(10)", "Sh5(11)")

# Other
otheridx <- c(17:22)
other.names <- c("Rn5(12)", "Rn10(13)", "Rnd(14)", "IdIn(15)", "InUn(16)", "IdUn(17)")
```

Here I study in detail simulations from a MASH model that extends the "model with independent, unique, and shared effects" from my larger [simulation study](MASHvFLASHsims.html). I run 10 simulations, each of which simulates data for 20 conditions and 1200 tests. I use 17 different covariance structures, each of which are used to simulate 25 tests. The other 775 tests are null across all conditions.

## Independent effects

Effects were nonnull for all conditions and generated independently from a $N(0, \sigma^2)$ distribution. I simulated $(1)$ small independent effects ($\sigma^2 = 2^2$), $(2)$ large independent effects ($\sigma^2 = 5^2$), and $(3)$ independent effects of varying sizes (with $\sigma^2$ ranging from $1^2$ to $5^2$).

Notice that cases 1 and 2 are covered by "canonical" covariance matrices in MASH, but 3 is not.

## Identical effects

Effects were nonnull for all conditions, with an effect size that was identical across conditions. The unique effect size was generated from a $N(0, \sigma^2)$ distribution. Similar to the above, I simulated $(4)$ small identical effects ($\sigma^2 = 2^2$)  and $(5)$ large identical effects ($\sigma^2 = 5^2$).

Both of these cases are covered by canonical covariance matrices in MASH.

## Rank-one effects

These are similar to "identical effects" in that the covariance matrix has rank one (so that conditions 2-20 are always fixed multiples of condition 1), but here, the effect sizes vary.

$(6)$ The effect size for condition 1 was generated from a $N(0, 1)$ distribution, and conditions 1-20 were multiples evenly spaced between 1 and 5.

Unlike identical effects, rank-one effects are not directly modeled by canonical covariance matrices.

## Unique effects

Effects were nonnull in one condition only, with the nonnull effect simulated from a $N(0, \sigma^2)$ distribution. I simulated $(7)$ small  effects ($\sigma^2 = 3^2$) unique to condition 1 and $(8)$ large effects ($\sigma^2 = 8^2$) unique to condition 2.

These effects are directly modeled by canonical covariance matrices.

## Shared effects

Effects were nonnull in several conditions. The nonnull effects were either identical across conditions or fixed multiples of one another. I included $(9)$ medium effects ($\sigma^2 = 3^2$) identical across 3 conditions (3-5), $(10)$ small effects ($\sigma^2 = 2^2$) identical across 10 conditions (1-10), and $(11)$ effects of differing sizes over 5 conditions (6-10), with variances ranging from $2^2$ to $4^2$.

None of these effects are modeled by canonical covariance matrices.

## Random covariance

I included three random covariance structures in which effects were nonnull across all conditions. In each case the random covariance matrix $A^T A$ was generated by sampling the entries of $A$ independently from a $N(0, 2^2)$ distribution. I included $(12)$ a rank-5 random covariance matrix (with $A \in \mathbb{R}^{5 \times 44}$), $(13)$ a rank-10 random covariance matrix $(A \in \mathbb{R}^{10 \times 44})$, and $(14)$ a full-rank random covariance matrix $(A \in \mathbb{R}^{44 \times 44})$.

## Combinations of independent, identical, and unique effects

Finally, I included several combinations of the above types of effects. In particular, I simulated $(15)$ small identical effects (covariance type 4) plus large independent effects (type 2), $(16)$ small independent effects (type 1) plus a large unique effect (type 8), and $(17)$ small identical effects (type 4) plus a large unique effect (type 8).

## Fitting methods

For each simulation, I fitted a MASH model and two FLASH models using the "one-hots last" method described in my larger [simulation study](MASHvFLASHsims.html). One FLASH model used the point-normal approach to solve the ebnm problem (`ebnm_fn = ebnm_pn`); the other used `ashr` (`ebnm_fn = ebnm_ash`).

## Results: RRMSE 

Here I give a detailed breakdown of the relative root mean-squared errors (that is, the RMSE for each fit object, divided by the RMSE that would be obtained by simply using the observed data $Y$ to estimate the "true effects" $X$). In addition to calculating the RRMSE separately for each covariance type, I also separately consider null effects and nonnull effects. 

MASH does much better in shrinking null effects towards zero, particularly for tests that are null across all conditions or that are unique to a single condition (covariance types 7-8). MASH also does consistently better in estimating nonnull effects when effects are independent across conditions (types 1-3). (In such cases, FLASH does worse than the naive estimate $\hat{X} = Y$.)

Results for other covariance types are more varied: MASH appears to do better on identical effects (types 4-5, whose covariance structures are included as "canonical"), but slightly worse on rank-one effects (type 6, which is not accounted for by canonical covariance matrices). FLASH seems to outperform MASH on shared effects (types 9-11), but (somewhat surprisingly) MASH does better on random covariance matrices and on combinations involving independent effects (types 12-16), with an RRMSE near 1 (whereas FLASH is again outperformed by the naive estimate $\hat{X} = Y$). Finally, FLASH does much better on a combination of identical and unique effects (type 17).

In general, the ash fits perform very similarly to the point-normal fits.

RRMSE for null effects is as follows (where "null" below refers to tests that are null across *all* conditions):

```{r mse_null}
par(mar = c(5,4,4,6))

legend.names <- c("FL-pn", "FL-ash", "MASH")
legend.args <- list(x="right", bty="n", inset=c(-0.25,0), xpd=T)
barplot(all.rrmses[,nullidx], names.arg = null.names, beside=T,
        ylim=c(0, 1), ylab="RRMSE", main="RRMSE for null effects",
        legend.text=legend.names, args.legend=legend.args)
```

And RRMSE for nonnull effects is as follows.

```{r mse_nonnull}
par(mar = c(5,4,4,6))
barplot(all.rrmses[,indididx], names.arg = indid.names, beside=T,
        ylim=c(0, 2), ylab="RRMSE", main="RRMSE for nonnull effects",
        legend.text=legend.names, args.legend=legend.args)
barplot(all.rrmses[,unshidx], names.arg = unsh.names, beside=T,
        ylim=c(0, 2), ylab="RRMSE", main="",
        legend.text=legend.names, args.legend=legend.args)
barplot(all.rrmses[,otheridx], names.arg = other.names, beside=T,
        ylim=c(0, 2), ylab="RRMSE", main="",
        legend.text=legend.names, args.legend=legend.args)
```

## Results: FPR/TPR

As in the larger [simulation study](MASHvFLASHsims.html), I evaluate true and false positive rates using the built-in function `get_lfsr()` for MASH and by simulating from the posterior for FLASH. For each covariance structure, I plot the true positive rate for a given covariance structure against the *overall* false positive rate.

An examination of the ROC curves leads to somewhat different conclusions to the above. As above, MASH does much better with respect to independent effects (types 1-3), random covariance matrices (types 12-14), and a combination of identical and independent effects (type 15), while FLASH outperforms MASH on a combination of identical and unique effects (type 17). Interestingly, point-normal priors outperform ash priors in all of these cases.

MASH does slightly better with respect to both identical effects (types 4-5) and rank-one effects (type 6), even though FLASH did better on the latter in terms of RRMSE. All methods perform similarly for both unique and shared effects (types 7-11), with ash priors doing somewhat better than point-normal priors for unique effects. Both MASH and FLASH-pn do well on a combination of independent and unique effects, while FLASH-ash performs poorly.

In general, it appears that one can safely opt for the faster point-normal priors over the slower but more flexible ash priors.

```{r tpr}
get_fpr <- function(pr) {
  nullidx <- c(7, 9, 11, 13, 15)
  fp <- 25 * rowSums(pr[, nullidx]) + 775 * (pr[, 23])
  fp / (25 * length(nullidx) + 775)
}
plot_fprvtpr <- function(idx, typename) {
  plot(get_fpr(pr.pn), pr.pn[, idx], type='l', col="red1", lty=2,
       xlab="FPR", ylab="TPR", ylim=c(0, 1), main=typename)
  lines(get_fpr(pr.ash), pr.ash[, idx], col="red4", lty=2)
  lines(get_fpr(pr.m), pr.m[, idx], col="blue")
  legend("bottomright", legend=c("Fl-pn", "Fl-ash", "MASH"),
         col=c("red1", "red4", "blue"), lty=c(2, 2, 1))
}

par(mfrow=c(1, 3))
plot_fprvtpr(1, "Small independent (1)")
plot_fprvtpr(2, "Large independent (2)")
plot_fprvtpr(3, "Independent of varying size (3)")

plot_fprvtpr(4, "Small identical (4)")
plot_fprvtpr(5, "Large identical (5)")
plot_fprvtpr(6, "Rank-one (6)")

par(mfrow=c(1, 2))
plot_fprvtpr(8, "Small unique (7)")
plot_fprvtpr(10, "Large unique (8)")

par(mfrow=c(1, 3))
plot_fprvtpr(12, "Shared (3 conditions) (9)")
plot_fprvtpr(14, "Shared (10 conditions) (10)")
plot_fprvtpr(16, "Shared (varying sizes) (11)")

plot_fprvtpr(17, "Random rank-5 (12)")
plot_fprvtpr(18, "Random rank-10 (13)")
plot_fprvtpr(19, "Random full-rank (14)")

plot_fprvtpr(20, "Identical plus independent (15)")
plot_fprvtpr(21, "Independent plus unique (16)")
plot_fprvtpr(22, "Identical plus unique (17)")
```

## Code

Click the "Code" button to view the code used to obtain the above results.
```{r code, echo=F, include=F}
knitr::read_chunk("./code/sims2.R")
```
```{r sims2, eval=F}
```

